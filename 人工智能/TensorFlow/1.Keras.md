# Keras

![image-20220420105934588](https://pic-1300286858.cos.ap-nanjing.myqcloud.com//uPic/2022-04/image-20220420105934588.png)

Keras 是一个用 Python 编写的高级神经网络 API，它能够以 [TensorFlow](https://github.com/tensorflow/tensorflow), [CNTK](https://github.com/Microsoft/cntk) 或者 [Theano](https://github.com/Theano/Theano) 作为后端运行。Keras 的开发重点是支持快速的实验。*能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。*

如果你在以下情况下需要深度学习库，请使用 Keras:

- 允许简单而快速的原型设计（由于用户友好，高度模块化，可扩展性）。
- 同时支持卷积神经网络和循环神经网络，以及两者的组合。
- 在 CPU 和 GPU 上无缝运行。

## 1. 简介

### 1.1 多后端 Keras 和 tf.keras:

**目前，我们推荐使用 TensorFlow 后端的 Keras 用户切换至 TensorFlow 2.0 的 `tf.keras`。** `tf.keras` 具有更好的维护，并且更好地集成了 TensorFlow 功能（eager执行，分布式支持及其他）。

Keras 2.2.5 是最后一个实现 2.2.* API 的 Keras 版本。它是最后一个仅支持 TensorFlow 1（以及 Theano 和 CNTK）的版本。

Keras 的当前版本是 2.3.0，它对 API 做了重大的调整，并且添加了 TensorFlow 2.0 的支持。2.3.0 将会是最后一个多后端 Keras 主版本。多后端 Keras 已被 `tf.keras` 取代。

> 结论： 使用tf.keras ，而不是单独安装的pip install  keras

### 1.2 指导原则

- **用户友好。** Keras 是为人类而不是为机器设计的 API。它把用户体验放在首要和中心位置。Keras 遵循减少认知困难的最佳实践：它提供一致且简单的 API，将常见用例所需的用户操作数量降至最低，并且在用户错误时提供清晰和可操作的反馈。
- **模块化。** 模型被理解为由独立的、完全可配置的模块构成的序列或图。这些模块可以以尽可能少的限制组装在一起。特别是神经网络层、损失函数、优化器、初始化方法、激活函数、正则化方法，它们都是可以结合起来构建新模型的模块。
- **易扩展性。** 新的模块是很容易添加的（作为新的类和函数），现有的模块已经提供了充足的示例。由于能够轻松地创建可以提高表现力的新模块，Keras 更加适合高级研究。
- **基于 Python 实现。** Keras 没有特定格式的单独配置文件。模型定义在 Python 代码中，这些代码紧凑，易于调试，并且易于扩展。

### 1.3 Keras 拥有强大的多 GPU 和分布式训练支持

- Keras [内置对多 GPU 数据并行的支持](https://keras.io/zh/utils/#multi_gpu_model)。
- 优步的 [Horovod](https://github.com/uber/horovod) 对 Keras 模型拥有一流的支持。
- Keras 模型[可以被转换为 TensorFlow Estimators](https://www.tensorflow.org/versions/master/api_docs/python/tf/keras/estimator/model_to_estimator) 并在 [Google Cloud 的 GPU 集群](https://cloud.google.com/solutions/running-distributed-tensorflow-on-compute-engine)上训练。
- Keras 可以在 Spark（通过 CERN 的 [Dist-Keras](https://github.com/cerndb/dist-keras)）和 [Elephas](https://github.com/maxpumperla/elephas) 上运行。

## 2. 模型接口

在 Keras 中有两类主要的模型：[Sequential 顺序模型](https://keras-zh.readthedocs.io/models/sequential) 和 [使用函数式 API 的 Model 类模型](https://keras-zh.readthedocs.io/models/model)。

### 2.1 Sequential顺序模型

这些模型有许多共同的方法和属性：

- `model.layers` 是包含模型网络层的展平列表。
- `model.inputs` 是模型输入张量的列表。
- `model.outputs` 是模型输出张量的列表。
- `model.summary()` 打印出模型概述信息。 它是 [utils.print_summary](https://keras-zh.readthedocs.io/utils/#print_summary) 的简捷调用。
- `model.get_config()` 返回包含模型配置信息的字典。通过以下代码，就可以根据这些配置信息重新实例化模型：

- `model.get_weights()` 返回模型中所有权重张量的列表，类型为 Numpy 数组。
- `model.set_weights(weights)` 从 Numpy 数组中为模型设置权重。列表中的数组必须与 `get_weights()` 返回的权重具有相同的尺寸。
- `model.to_json()` 以 JSON 字符串的形式返回模型的表示。请注意，该表示不包括权重，仅包含结构。你可以通过以下方式从 JSON 字符串重新实例化同一模型（使用重新初始化的权重）：

```
from keras.models import model_from_json

json_string = model.to_json()
model = model_from_json(json_string)
```

- `model.to_yaml()` 以 YAML 字符串的形式返回模型的表示。请注意，该表示不包括权重，只包含结构。你可以通过以下代码，从 YAML 字符串中重新实例化相同的模型（使用重新初始化的权重）：

```
from keras.models import model_from_yaml

yaml_string = model.to_yaml()
model = model_from_yaml(yaml_string)
```

- `model.save_weights(filepath)` 将模型权重存储为 HDF5 文件。
- `model.load_weights(filepath, by_name=False)`: 从 HDF5 文件（由 `save_weights` 创建）中加载权重。默认情况下，模型的结构应该是不变的。 如果想将权重载入不同的模型（部分层相同）， 设置 `by_name=True` 来载入那些名字相同的层的权重。

### 2.2 Model类继承

```python
import keras

class SimpleMLP(keras.Model):

    def __init__(self, use_bn=False, use_dp=False, num_classes=10):
        super(SimpleMLP, self).__init__(name='mlp')
        self.use_bn = use_bn
        self.use_dp = use_dp
        self.num_classes = num_classes

        self.dense1 = keras.layers.Dense(32, activation='relu')
        self.dense2 = keras.layers.Dense(num_classes, activation='softmax')
        if self.use_dp:
            self.dp = keras.layers.Dropout(0.5)
        if self.use_bn:
            self.bn = keras.layers.BatchNormalization(axis=-1)

    def call(self, inputs):
        x = self.dense1(inputs)
        if self.use_dp:
            x = self.dp(x)
        if self.use_bn:
            x = self.bn(x)
        return self.dense2(x)

model = SimpleMLP()
model.compile(...)
model.fit(...)


'''
在类继承模型中，模型的拓扑结构是由 Python 代码定义的（而不是网络层的静态图）。这意味着该模型的拓扑结构不能被检查或序列化。因此，以下方法和属性不适用于类继承模型：

    model.inputs 和 model.outputs。
    model.to_yaml() 和 model.to_json()。
    model.get_config() 和 model.save()。
'''
```

## 3. 训练和验证接口

### 3.1 compile方法

```python
compile(optimizer, loss=None, metrics=None, loss_weights=None, sample_weight_mode=None, weighted_metrics=None, target_tensors=None)
```

- **optimizer**: 字符串（优化器名）或者优化器对象。详见 [optimizers](https://keras-zh.readthedocs.io/optimizers)。
- **loss**: 字符串（目标函数名）或目标函数或 `Loss` 实例。详见 [losses](https://keras-zh.readthedocs.io/losses)。    如果模型具有多个输出，则可以通过传递损失函数的字典或列表，在每个输出上使用不同的损失。模型将最小化的损失值将是所有单个损失的总和。
- **metrics**: 在训练和测试期间的模型评估标准。    通常你会使用 `metrics = ['accuracy']`。要为多输出模型的不同输出指定不同的评估标准，    还可以传递一个字典，如 `metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']}`。    你也可以传递一个评估指标序列的序列 (len = len(outputs)) 例如 `metrics=[['accuracy'], ['accuracy', 'mse']]`    或 `metrics=['accuracy', ['accuracy', 'mse']]`。
- **loss_weights**: 指定标量系数（Python浮点数）的可选列表或字典，用于加权不同模型输出的损失贡献。    模型将要最小化的损失值将是所有单个损失的加权和，由 `loss_weights` 系数加权。    如果是列表，则期望与模型的输出具有 1:1 映射。    如果是字典，则期望将输出名称（字符串）映射到标量系数。
- **sample_weight_mode**: 如果你需要执行按时间步采样权重（2D 权重），请将其设置为 `temporal`。    默认为 `None`，为采样权重（1D）。如果模型有多个输出，则可以通过传递 mode 的字典或列表，以在每个输出上使用不同的 `sample_weight_mode`。
- **weighted_metrics**: 在训练和测试期间，由 sample_weight 或 class_weight 评估和加权的度量标准列表。

### 3.2 fit

```python
fit(x=None, y=None, batch_size=None, epochs=1, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0, steps_per_epoch=None, validation_steps=None, validation_freq=1, max_queue_size=10, workers=1, use_multiprocessing=False)
```

**x**: 输入数据。可以是：

- 一个 Numpy 数组（或类数组），或者数组的序列（如果模型有多个输入）。
- 一个将名称匹配到对应数组/张量的字典，如果模型具有命名输入。
- 一个返回 `(inputs, targets)` 或 `(inputs, targets, sample weights)`   的生成器或 `keras.utils.Sequence`。
- None（默认），如果从本地框架张量馈送（例如 TensorFlow 数据张量）。

**y**: 目标数据。与输入数据 `x` 类似，它可以是 Numpy 数组（序列）、    本地框架张量（序列）、Numpy数组序列（如果模型有多个输出）    或 None（默认）如果从本地框架张量馈送（例如 TensorFlow 数据张量）。    如果模型输出层已命名，你也可以传递一个名称匹配 Numpy 数组的字典。    如果 `x` 是一个生成器，或 `keras.utils.Sequence` 实例，则不应该    指定 `y`（因为目标可以从 `x` 获得）。

**epochs**: 整数。训练模型迭代轮次。一个轮次是在整个 `x` 或 `y` 上的一轮迭代。    请注意，与 `initial_epoch` 一起，`epochs` 被理解为「最终轮次」。    模型并不是训练了 `epochs` 轮，而是到第 `epochs` 轮停止训练。

**verbose**: 整数，0, 1 或 2。日志显示模式。    0 = 安静模式, 1 = 进度条, 2 = 每轮一行。

**callbacks**: 一系列的 `keras.callbacks.Callback` 实例。一系列可以在训练和验证（如果有）时使用的回调函数。    详见 [callbacks](https://keras-zh.readthedocs.io/callbacks)。

**validation_split**: 0 和 1 之间的浮点数。用作验证集的训练数据的比例。    模型将分出一部分不会被训练的验证数据，并将在每一轮结束时评估这些验证数据的误差和任何其他模型指标。    验证数据是混洗之前 `x` 和`y` 数据的最后一部分样本中。    这个参数在 `x` 是生成器或 `Sequence` 实例时不支持。

**validation_data**: 用于在每个轮次结束后评估损失和任意指标的数据。    模型不会在这个数据上训练。`validation_data` 会覆盖 `validation_split`。    `validation_data` 可以是：

- 元组 `(x_val, y_val)` 或 Numpy 数组或张量
- 元组 `(x_val, y_val, val_sample_weights)` 或 Numpy 数组。
- 数据集或数据集迭代器。

对于前两种情况，必须提供 `batch_size`。 对于最后一种情况，必须提供 `validation_steps`。

**shuffle**: 布尔值（是否在每轮迭代之前混洗数据）或者字符串 (`batch`)。    `batch` 是处理 HDF5 数据限制的特殊选项，它对一个 batch 内部的数据进行混洗。    当 `steps_per_epoch` 非 `None` 时，这个参数无效。

**class_weight**: 可选的字典，用来映射类索引（整数）到权重（浮点）值，用于加权损失函数（仅在训练期间）。    这可能有助于告诉模型「更多关注」来自代表性不足的类的样本。

**sample_weight**: 训练样本的可选 Numpy 权重数组，用于对损失函数进行加权（仅在训练期间）。    你可以传递与输入样本长度相同的平坦（1D）Numpy 数组（权重和样本之间的 1:1 映射），    或者在时序数据的情况下，可以传递尺寸为 `(samples, sequence_length)` 的 2D 数组，以对每个样本的每个时间步施加不同的权重。    在这种情况下，你应该确保在 `compile()` 中指定 `sample_weight_mode="temporal"`。    这个参数在 `x` 是生成器或 `Sequence` 实例时不支持，应该提供 sample_weights 作为 `x` 的第 3 元素。

**initial_epoch**: 整数。开始训练的轮次（有助于恢复之前的训练）。

**steps_per_epoch**: 整数或 `None`。    在声明一个轮次完成并开始下一个轮次之前的总步数（样品批次）。    使用 TensorFlow 数据张量等输入张量进行训练时，默认值 `None` 等于数据集中样本的数量除以 batch 的大小，如果无法确定，则为 1。

**validation_steps**: 只有在提供了 `validation_data` 并且时一个生成器时才有用。    表示在每个轮次结束时执行验证时，在停止之前要执行的步骤总数（样本批次）。

**validation_freq**: 只有在提供了验证数据时才有用。整数或列表/元组/集合。    如果是整数，指定在新的验证执行之前要执行多少次训练，例如，`validation_freq=2` 在每 2 轮训练后执行验证。    如果是列表、元组或集合，指定执行验证的轮次，例如，`validation_freq=[1, 2, 10]` 表示在第 1、2、10 轮训练后执行验证。

**max_queue_size**: 整数。仅用于生成器或 `keras.utils.Sequence` 输入。    生成器队列的最大尺寸。若未指定，`max_queue_size` 将默认为 10。

**workers**: 整数。仅用于生成器或 `keras.utils.Sequence` 输入。    当使用基于进程的多线程时的最大进程数。若未指定，`workers` 将默认为 1。若为 0，将在主线程执行生成器。

**use_multiprocessing**: 布尔值。仅用于生成器或 `keras.utils.Sequence` 输入。    如果是 `True`，使用基于进程的多线程。若未指定，`use_multiprocessing` 将默认为 `False`。    注意由于这个实现依赖于 multiprocessing，你不应该像生成器传递不可选的参数，因为它们不能轻松地传递给子进程。

###  3.3 evaluate

```
evaluate(x=None, y=None, batch_size=None, verbose=1, sample_weight=None, steps=None, callbacks=None, max_queue_size=10, workers=1, use_multiprocessing=False)
```

在测试模式，返回误差值和评估标准值。

### 3.4 predict

```python
predict(x, batch_size=None, verbose=0, steps=None, callbacks=None, max_queue_size=10, workers=1, use_multiprocessing=False)
```

为输入样本生成输出预测。

### 3.5 train_on_batch

```python
train_on_batch(x, y, sample_weight=None, class_weight=None, reset_metrics=True)
```

**Arguments**

- **x**: 训练数据的 Numpy 数组（如果模型只有一个输入），    或者是 Numpy 数组的列表（如果模型有多个输入）。    如果模型中的输入层被命名，你也可以传递一个字典，将输入层名称映射到 Numpy 数组。
- **y**: 目标（标签）数据的 Numpy 数组，或 Numpy 数组的列表（如果模型具有多个输出）。    如果模型中的输出层被命名，你也可以传递一个字典，将输出层名称映射到 Numpy 数组。
- **sample_weight**: 可选数组，与 x 长度相同，包含应用到模型损失函数的每个样本的权重。    如果是时域数据，你可以传递一个尺寸为 (samples, sequence_length) 的 2D 数组，    为每一个样本的每一个时间步应用不同的权重。    在这种情况下，你应该在 `compile()` 中指定 `sample_weight_mode="temporal"`。
- **class_weight**: 可选的字典，用来映射类索引（整数）到权重（浮点）值，以在训练时对模型的损失函数加权。    这可能有助于告诉模型 「更多关注」来自代表性不足的类的样本。
- **reset_metrics**: 如果为 `True`，返回的指标仅适用于该批次。    如果为 `False`，则指标将在批次之间有状态地累积。

### 3.6 test_on_batch

```python
test_on_batch(x, y, sample_weight=None)
```

### 3.7 predict_on_batch

